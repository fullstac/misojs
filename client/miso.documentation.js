module.exports = function(){ return {"Goals.md":"Primary goals\n=============\n\n* Easy setup of [isomorphic](http://isomorphic.net/) application based on [mithril](https://github.com/lhorie/mithril.js)\n* Skeleton / scaffold / Boilerplate to allow users to very quickly get up and running.\n* minimal core\n* easy extendible\n* DB agnostic (e. G. plugins for different ORM/ODM)\n\nComponents\n==========\n\n* Routing\n* View rendering\n* i18n/l10n\n* Rest-API (could use restify: http://mcavage.me/node-restify/)\n* optional Websockets (could use restify: http://mcavage.me/node-restify/)\n* easy testing (headless and Browser-Tests)\n* login/session handling\n* models with validation\n\nUseful libs\n===========\n\nHere are some libraries we are considering using, (in no particular order):\n\n* leveldb\n* mithril-query\n* translate.js\n* i18next\n\nAnd some that we're already using:\n\n* express\n* browserify\n* mocha/expect\n* mithril-node-render\n* mithril-sugartags\n* mithril-bindings\n* mithril-animate\n* lodash\n* validator\n","Home.md":"Welcome to the misojs wiki!\n\nGetting started\n===============\n\nSee the [install guide](https://github.com/jsguy/misojs#install).\nRead [how miso works](../How-miso-works), and check out [the patterns](../Patterns), then create something cool!\n","How-miso-works.md":"## Models, views, controllers\n\nWhen creating a route, you must assign a controller and a view to it - this is achieved by creating a file in the `/mvc` directory - by convention, you should name it as per the path you want, (see the [routing section](#routing) for details).\n\nHere is a minimal example using the sugartags, and getting a parameter:\n\n```javascript\nvar m = require('mithril'),\n\tmiso = require('../server/miso.util.js'),\n\tsugartags = require('../server/mithril.sugartags.node.js')(m);\n\nmodule.exports.index = {\n\tcontroller: function(params) {\n\t\tthis.who = miso.getParam('who', params, 'world');\n\t\treturn this;\n\t},\n\tview: function(ctrl){\n\t\twith(sugartags) {\n\t\t\treturn DIV('Hello ' + ctrl.who);\n\t\t}\n\t}\n};\n```\n\nSave this into a file `/mvc/hello.js`, and open http://localhost/hellos, this will show \"Hello world\". Note the 's' on the end - this is due to how the [route by convention](#route-by-convention) works.\n\nNow open `/cfg/routes.json`, and add the following routes:\n\n```javascript\n\t\"/hello\": { \"method\": \"get\", \"name\": \"hello\", \"action\": \"index\" },\n\t\"/hello/:who\": { \"method\": \"get\", \"name\": \"hello\", \"action\": \"index\" }\n```\n\nSave the file, and go back to the browser, and you'll see an error! This is because we have now overridden the automatic route. Open http://localhost/hello, and you'll see our action. Now open http://localhost/hello/YOURNAME, and you'll see it getting the first parameter, and greeting you!\n\n## Routing\n\nThe routing can be defined in one of two ways\n\n### Route by convention\n\nYou can use a naming convention as follows:\n\n|Action \t\t|Method \t\t|URL \t\t\t\t\t\t|Description|\n|---------------|---------------|---------------------------|-----------|\n|index \t\t|GET \t\t|[controller] + 's'\t\t\t|List the items|\n|edit \t\t|GET \t\t|[controller]/[id]\t\t\t|Display a form to edit the item|\n|new \t\t|GET \t\t|[controller] + 's' + '/new' \t\t\t|Display a form to add a new item|\n\nSay you have a mvc file named \"user.js\", and you define an action like so:\n\n```javascript\nmodule.exports.index = {...\n```\n\nMiso will automatically map a \"GET\" to \"/users\".  \nNow say you have a mvc file named \"user.js\", and you define an action like so:\n\n```javascript\nmodule.exports.edit = {...\n```\nMiso will automatically map a \"GET\" to \"/user/:user_id\", so that users can access via a route such as \"/user/27\" for use with ID of 27. *Note:* You can get the user_id using a miso utility: `var userId = miso.getParam('user_id', params);`.\n\n### Route by configuration\n\nBy using `/cfg/routes.json` config file:\n\n```javascript\n{\n\t\"[Pattern]\": { \"method\": \"[Method]\", \"name\": \"[Route name]\", \"action\": \"[Action]\" }\n}\n``` \n\nWhere:\n\n* **Pattern** - the [route pattern](#routing-patterns) we want, including any parameters\n* **Method** - one of 'GET', 'POST', 'PUT', 'DELETE'\n* **Route** name - name of your route file from /mvc\n* **Action** - name of the action to call on your route file from /mvc\n\n**Example**\n\n```javascript\n{\n\t\"/\": { \"method\": \"get\", \"name\": \"home\", \"action\": \"index\" }\n}\n``` \n\nThis will map a \"GET\" to the root of the URL for the `index` action in `home.js`\n\n**Note:** The routing config will override any automatically defined routes, so if you need multiple routes to point to the same action, you must manually define them. For example, if you have a mvc file named \"term.js\", and you define an action like so:\n\n```javascript\nmodule.exports.index = {...\n```\n\nMiso will automatically map a \"GET\" to \"/terms\". Now, if you want to map it also to \"/AGB\", you will need to add two entries in the routes config:\n\n```javascript\n{\n\t\"/terms\": { \"method\": \"get\", \"name\": \"terms\", \"action\": \"index\" },\n\t\"/AGB\": { \"method\": \"get\", \"name\": \"terms\", \"action\": \"index\" }\n}\n``` \n\nThis is because Miso assumes that if you override the defaulted routes, you actually want to replace them, not just override them. *Note:* this is correct behaviour, as it minority case is when you want more than one route pointing to the same action.\n\n### Routing patterns\n\n|Type\t\t\t| Example|\n|---------------|---------|\n|Path \t\t\t| \"/abcd\" - match paths starting with /abcd|\n|Path Pattern\t| \"/abc?d\" - match paths starting with /abcd and /abd|\n|Path Pattern\t| \"/ab+cd\" - match paths starting with /abcd, /abbcd, /abbbbbcd and so on|\n|Path Pattern\t| \"/ab*cd\" - match paths starting with /abcd, /abxcd, /abFOOcd, /abbArcd and so on|\n|Path Pattern\t| \"/a(bc)?d\" - will match paths starting with /ad and /abcd|\n|Regular Expression| /\\/abc\\|\\/xyz/ - will match paths starting with /abc and /xyz|\n|Array\t\t\t| [\"/abcd\", \"/xyza\", /\\/lmn\\|\\/pqr/] - match paths starting with /abcd, /xyza, /lmn, and /pqr|\n\n### Links\n\nWhen you create links, in order to get the app to work as an SPA, you must pass in m.route as a config, so that the history will be updated correctly, for example:\n\n```javascript\nA({href:\"/users/new\", config: m.route}, \"Add new user\")\n```\n\nThis will correctly work as a SPA. If you leave out `config: m.route`, the app will still work, but the page will reload every time the link is followed.\n\n* Lightweight footprint\n* Full-stack isomorphic framework\n* SPA that renders the initial page server side\n* Data models with isomorphic validation\n* Auto-reload browser on changes\n\n## Data models\n\nData models are progressively enhanced mithril models - you simply create your model as usual, then add validation and type information as it becomes pertinent.\nFor example, say you have a model like so:\n\n```javascript\nvar userModel = function(data){\n\tthis.name = m.p(data.name||\"\");\n\tthis.email = m.p(data.email||\"\");\n\tthis.id = m.p(data._id||\"\");\n\treturn this;\n}\n\n```\n\nIn order to make it validatable, add the validator module:\n\n```javascript\nvar validate = require('validator.modelbinder');\n```\n\nThen add a `isValid` validation method to your model, with any declarations based on [node validator](https://github.com/chriso/validator.js#validators):\n\n```javascript\nvar userModel = function(data){\n\tthis.name = m.p(data.name||\"\");\n\tthis.email = m.p(data.email||\"\");\n\tthis.id = m.p(data._id||\"\");\n\n\t//\tValidate the model\t\t\n\tthis.isValid = validate.bind(this, {\n\t\tname: {\n\t\t\tisRequired: \"You must enter a name\"\n\t\t},\n\t\temail: {\n\t\t\tisRequired: \"You must enter an email address\",\n\t\t\tisEmail: \"Must be a valid email address\"\n\t\t}\n\t});\n\n\treturn this;\n};\n```\n\nThis creates a method that the miso database adaptor can use to validate your model.\nYou get full access to the validation info as well, so you can show an error message near your field, for example:\n\n```javascript\nuser.isValid('email')\n```\n\nWill return `true` if the `email` property of your user model is valid, or a list of errors messages if it is invalid:\n\n```javascript\n[\"You must enter an email address\", \"Must be a valid email address\"]\n```\n\nSo you can for example add a class name to a div surrounding your field like so:\n\n```javascript\nDIV({class: (ctrl.user.isValid('email') == true? \"valid\": \"invalid\")}, [...\n```\n\nAnd show the error messages like so:\n\n```javascript\nSPAN(ctrl.user.isValid('email') == true? \"\": ctrl.user.isValid('email').join(\", \"))\n```\n\nTODO: Add progressive type enhancement","Patterns.md":"There are several ways you can write your app and miso is not opinionated about how you go about this so it is important that you choose a pattern that suits your needs. Below are a few suggested patterns to follow when developing apps.\n\n**Note:** miso is a single page app that loads server rendered HTML from any URL, so that SEO works out of the box.\n\n## Single url mvc\n\nIn this pattern everything that your mvc needs to do is done on a single url for all the associated actions. The advantage for this style of development is that you have everything in one mvc container, and you don't need to map any routes - of course the downside being that there are no routes for the user to bookmark. This is pattern works well for smaller entities where there are not too many interactions that the user can do - this is essentially how most mithril apps are written - self-contained, and at a single url.\n\nHere is a \"hello world\" example using the single url pattern\n\n```javascript\nvar m = require('mithril'),\n\tsugartags = require('../server/mithril.sugartags.node.js')(m);\n\nvar self = module.exports.index = {\n\tmodels: {\n\t\t//\tOur model\n\t\thello: function(data){\n\t\t\tthis.who = m.p(data.who);\n\t\t}\n\t},\n\tcontroller: function(params) {\n\t\tthis.model = new self.models.hello({who: \"world\"});\n\t\treturn this;\n\t},\n\tview: function(ctrl) {\n\t\tvar model = ctrl.model;\n\t\twith(sugartags) {\n\t\t\treturn [\n\t\t\t\tDIV(\"Hello \" + model.who())\n\t\t\t];\n\t\t}\n\t}\n};\n```\n\nThis would expose a url /hellos (note: the 's'), and would display \"Hello world\". (You can change the route using custom routing)\n\n## Multi url mvc\n\nIn this pattern we expose multiple mvc routes that in turn translate to multiple URLs. This is useful for splitting up your app, and ensuring each mvc has its own sets of concerns.\n\n```javascript\nvar m = require('mithril'),\n\tmiso = require('../server/miso.util.js'),\n\tsugartags = require('../server/mithril.sugartags.node.js')(m);\n\nvar index = module.exports.index = {\n\tmodels: {\n\t\t//\tOur model\n\t\thello: function(data){\n\t\t\tthis.who = m.p(data.who);\n\t\t}\n\t},\n\tcontroller: function(params) {\n\t\tthis.model = new index.models.hello({who: \"world\"});\n\t\treturn this;\n\t},\n\tview: function(ctrl) {\n\t\tvar model = ctrl.model;\n\t\twith(sugartags) {\n\t\t\treturn [\n\t\t\t\tDIV(\"Hello \" + model.who()),\n\t\t\t\tA({href: \"/hello/Leo\", config: m.route}, \"Click me for the edit action\")\n\t\t\t];\n\t\t}\n\t}\n};\n\nvar edit = module.exports.edit = {\n\tcontroller: function(params) {\n\t\tvar who = miso.getParam('hello_id', params);\n\t\tthis.model = new index.models.hello({who: who});\n\t\treturn this;\n\t},\n\tview: function(ctrl) {\n\t\tvar model = ctrl.model;\n\t\twith(sugartags) {\n\t\t\treturn [\n\t\t\t\tDIV(\"Hello \" + model.who())\n\t\t\t];\n\t\t}\n\t}\n};\n```\n\nHere we also expose a \"/hello/[NAME]\" url, that will show your name when you visit /hello/[YOUR NAME], so there are now multiple urls for our SPA:\n\n* **/hellos** - this is intended to be an index page that lists all your \"hellos\"\n* **/hello/[NAME]** - this is intended to be an edit page where you can edit your \"hellos\"\n\nNote that the anchor tag has `config: m.route` in it's options - this is so that we can route automatically though mithril"}; };